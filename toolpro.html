<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>LSB Invisible Watermark Tool</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    h1, h2 {
      text-align: center;
    }
    .section {
      border: 1px solid #ccc;
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 25px;
    }
    textarea {
      width: 100%;
      min-height: 80px;
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      justify-content: center;
      align-items: flex-start;
    }
    canvas, img {
      max-width: 100%;
      border: 1px solid #ccc;
      border-radius: 8px;
    }
    button {
      padding: 8px 16px;
      margin-top: 10px;
      cursor: pointer;
    }
    #decodeResult {
      margin-top: 10px;
      font-weight: bold;
      color: green;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
  </style>
</head>
<body>
  <h1>LSB Invisible Watermark Tool</h1>
  <p style="text-align:center;">
    Ẩn / đọc watermark bằng kỹ thuật LSB (ẩn trong pixel). Ảnh xuất ra sẽ là PNG để không bị mất watermark.
  </p>

  <!-- ENCODE -->
  <div class="section">
    <h2>1. Encode – Nhúng watermark vào ảnh</h2>
    <div class="row">
      <div>
        <p><b>Chọn ảnh gốc:</b></p>
        <input type="file" id="encodeInput" accept="image/*">
        <p><b>Nội dung watermark:</b></p>
        <textarea id="watermarkText" placeholder="Nhập nội dung watermark ở đây (ví dụ: MSSV:25127xxx ; Gmail: ... ; Tên: ...)"></textarea>
        <button id="encodeBtn">Encode &amp; Tạo ảnh mới</button>
        <p id="encodeStatus"></p>
        <a id="downloadLink" style="display:none;" download="watermarked_lsb.png">Tải ảnh đã nhúng (PNG)</a>
      </div>
      <div>
        <p><b>Preview ảnh sau khi encode:</b></p>
        <canvas id="encodeCanvas"></canvas>
      </div>
    </div>
  </div>

  <!-- DECODE -->
  <div class="section">
    <h2>2. Decode – Đọc watermark từ ảnh đã nhúng</h2>
    <p><b>Chọn ảnh đã encode (PNG):</b></p>
    <input type="file" id="decodeInput" accept="image/*">
    <div id="decodeResult"></div>
  </div>

  <script>
    // =========================
    // Helper: encode message into ImageData using LSB on Red channel
    // =========================
    function encodeLSB(imageData, message) {
      const data = imageData.data;
      const msgLen = message.length;
      const totalBits = 32 + msgLen * 16; // 32 bit length + 16 bit per char
      const capacity = data.length / 4;   // 1 bit per pixel (red only)

      if (totalBits > capacity) {
        throw new Error("Watermark quá dài so với kích thước ảnh.");
      }

      // Tạo mảng bit
      const bits = [];

      // 32 bit độ dài (số ký tự), big-endian
      for (let i = 31; i >= 0; i--) {
        bits.push((msgLen >> i) & 1);
      }

      // Mỗi ký tự 16 bit (UTF-16 code unit)
      for (let j = 0; j < msgLen; j++) {
        const code = message.charCodeAt(j);
        for (let i = 15; i >= 0; i--) {
          bits.push((code >> i) & 1);
        }
      }

      // Gắn vào kênh Red
      for (let i = 0; i < bits.length; i++) {
        const pixelIndex = i * 4;            // R của từng pixel
        data[pixelIndex] = (data[pixelIndex] & 0xFE) | bits[i];
      }

      return imageData;
    }

    // =========================
    // Helper: decode message from ImageData using LSB on Red channel
    // =========================
    function decodeLSB(imageData) {
      const data = imageData.data;
      const capacity = data.length / 4;

      // Đọc 32 bit đầu -> length
      let lenBits = [];
      for (let i = 0; i < 32; i++) {
        const pixelIndex = i * 4;
        lenBits.push(data[pixelIndex] & 1);
      }
      let msgLen = 0;
      for (let i = 0; i < 32; i++) {
        msgLen = (msgLen << 1) | lenBits[i];
      }

      if (msgLen <= 0 || 32 + msgLen * 16 > capacity) {
        return null;
      }

      const bits = [];
      for (let i = 0; i < msgLen * 16; i++) {
        const pixelIndex = (32 + i) * 4;
        bits.push(data[pixelIndex] & 1);
      }

      let chars = [];
      for (let c = 0; c < msgLen; c++) {
        let code = 0;
        for (let i = 0; i < 16; i++) {
          code = (code << 1) | bits[c * 16 + i];
        }
        chars.push(String.fromCharCode(code));
      }

      return chars.join("");
    }

    // =========================
    // ENCODE logic
    // =========================
    const encodeInput = document.getElementById("encodeInput");
    const encodeCanvas = document.getElementById("encodeCanvas");
    const encodeBtn = document.getElementById("encodeBtn");
    const wmText = document.getElementById("watermarkText");
    const encodeStatus = document.getElementById("encodeStatus");
    const downloadLink = document.getElementById("downloadLink");

    let encodeImageLoaded = false;
    let encodeImageElement = new Image();

    encodeInput.addEventListener("change", function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(evt) {
        encodeImageElement = new Image();
        encodeImageElement.onload = function() {
          encodeCanvas.width = encodeImageElement.width;
          encodeCanvas.height = encodeImageElement.height;
          const ctx = encodeCanvas.getContext("2d");
          ctx.drawImage(encodeImageElement, 0, 0);
          encodeImageLoaded = true;
          encodeStatus.textContent = "Ảnh đã được load, nhập watermark rồi bấm Encode.";
          downloadLink.style.display = "none";
        };
        encodeImageElement.src = evt.target.result;
      };
      reader.readAsDataURL(file);
    });

    encodeBtn.addEventListener("click", function() {
      if (!encodeImageLoaded) {
        alert("Chưa chọn ảnh để encode.");
        return;
      }
      const message = wmText.value;
      if (!message) {
        alert("Nhập nội dung watermark trước đã.");
        return;
      }

      const ctx = encodeCanvas.getContext("2d");
      let imageData = ctx.getImageData(0, 0, encodeCanvas.width, encodeCanvas.height);

      try {
        imageData = encodeLSB(imageData, message);
      } catch (err) {
        alert(err.message);
        return;
      }

      ctx.putImageData(imageData, 0, 0);
      const dataURL = encodeCanvas.toDataURL("image/png");
      downloadLink.href = dataURL;
      downloadLink.style.display = "inline-block";
      encodeStatus.textContent = "Encode thành công! Bấm link để tải ảnh PNG đã nhúng watermark.";
    });

    // =========================
    // DECODE logic
    // =========================
    const decodeInput = document.getElementById("decodeInput");
    const decodeResult = document.getElementById("decodeResult");

    decodeInput.addEventListener("change", function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(evt) {
        const img = new Image();
        img.onload = function() {
          const canvas = document.createElement("canvas");
          canvas.width = img.width;
          canvas.height = img.height;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(img, 0, 0);
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const msg = decodeLSB(imageData);
          if (msg === null || msg.trim() === "") {
            decodeResult.textContent = "Không tìm thấy watermark (hoặc ảnh chưa encode).";
          } else {
            decodeResult.textContent = "Watermark: " + msg;
          }
        };
        img.src = evt.target.result;
      };
      reader.readAsDataURL(file);
    });
  </script>
</body>
</html>
